# Week 15, Day 1: Argparse & CLI Design

## üéØ Learning Objectives
- [ ] Understand the core principles of good Command-Line Interface (CLI) design.
- [ ] Learn to use Python's built-in `argparse` module to parse command-line arguments.
- [ ] Differentiate between positional arguments and optional arguments (options/flags).
- [ ] Implement CLIs with subcommands, similar to tools like `git` or `docker`.
- [ ] Customize help text and provide clear documentation for your CLI users.

## üìö Concepts

### 1. Principles of Good CLI Design
A good CLI is like a good API: it's predictable, well-documented, and easy to use.
-   **Discoverability**: The user should be able to figure out how to use your tool without reading the source code. A good `--help` message is crucial.
-   **Consistency**: Follow established conventions (e.g., `-v` for verbose, `--version` for the version). This makes your tool feel familiar.
-   **Simplicity**: Keep the interface clean. Use subcommands to group related actions rather than having dozens of top-level flags.
-   **Good Feedback**: Provide clear output. Let the user know what's happening. Use exit codes correctly (0 for success, non-zero for errors).
-   **Composability (The UNIX Philosophy)**: Design your tool to do one thing well and be easily combined with other tools via pipes (`|`) and redirection (`>`).

### 2. The `argparse` Module
The `argparse` module is Python's standard library for building command-line interfaces. It handles parsing arguments from `sys.argv`, generating help messages, and issuing errors when users give the program invalid arguments.

**Basic Example:**
```python
import argparse

# 1. Create the parser
parser = argparse.ArgumentParser(description="A simple program that greets the user.")

# 2. Add arguments
# This is a positional argument
parser.add_argument("name", type=str, help="The name to greet.")
# This is an optional argument (or "flag")
parser.add_argument("--times", "-t", type=int, default=1, help="Number of times to greet.")

# 3. Parse the arguments
args = parser.parse_args()

# 4. Use the arguments in your application logic
for _ in range(args.times):
    print(f"Hello, {args.name}!")
```

**How to run it:**
```bash
# Get the help message (auto-generated by argparse)
$ python my_script.py --help
# usage: my_script.py [-h] [--times TIMES] name
#
# A simple program that greets the user.
#
# positional arguments:
#   name                  The name to greet.
#
# options:
#   -h, --help            show this help message and exit
#   --times TIMES, -t TIMES
#                         Number of times to greet.

# Run the script
$ python my_script.py Alice
# Hello, Alice!

$ python my_script.py Bob --times 3
# Hello, Bob!
# Hello, Bob!
# Hello, Bob!
```

### 3. Positional vs. Optional Arguments

-   **Positional Arguments**:
    -   Defined by their name (e.g., `name`).
    -   They are required by default.
    -   The order matters.
    -   Example: `cp source_file destination_file`

-   **Optional Arguments (Options/Flags)**:
    -   Defined by a name prefixed with `-` (short name) or `--` (long name).
    -   They are optional by default.
    -   The order does not matter.
    -   Example: `ls -l -a` is the same as `ls -a -l`.

**Common `add_argument()` parameters:**
-   `type`: The type to which the argument should be converted (e.g., `int`, `float`).
-   `default`: The value to use if the argument is not provided.
-   `help`: The help message for this argument.
-   `required`: Makes an optional argument mandatory.
-   `action`: Specifies how the argument should be handled. `action='store_true'` is common for boolean flags (e.g., `--verbose`). If the flag is present, the value is `True`, otherwise `False`.

### 4. Subcommands
For complex tools, you can create a multi-level command structure using subcommands. Think of `git commit`, `git push`, `git pull`. Here, `commit`, `push`, and `pull` are subcommands of `git`.

```python
import argparse

# Main parser
parser = argparse.ArgumentParser(description="A fake version control system.")
subparsers = parser.add_subparsers(dest="command", help="Available commands", required=True)

# Parser for the "commit" command
parser_commit = subparsers.add_parser("commit", help="Commit changes to the repository.")
parser_commit.add_argument("-m", "--message", type=str, required=True, help="Commit message.")

# Parser for the "push" command
parser_push = subparsers.add_parser("push", help="Push changes to a remote.")
parser_push.add_argument("remote", type=str, help="The remote to push to.")
parser_push.add_argument("--force", action="store_true", help="Force the push.")

# Parse and handle
args = parser.parse_args()

if args.command == "commit":
    print(f"Committing with message: '{args.message}'")
elif args.command == "push":
    print(f"Pushing to remote '{args.remote}'...")
    if args.force:
        print("FORCING the push!")
```

### 5. Customizing Help Text
`argparse` does a great job of generating help text, but you can customize it further using `description`, `epilog`, and `help` messages. Providing clear, helpful text is one of the most important parts of good CLI design.

```python
parser = argparse.ArgumentParser(
    prog="mytool",
    description="This is a really cool tool that does amazing things.",
    epilog="For more help, see the online documentation at mytool.com"
)
```

## üîπ Quick Exercise
Create an `ArgumentParser` for a script that calculates the area of a rectangle.
-   It should take two **required, positional** arguments: `length` and `width`.
-   Both arguments should be of type `float`.
-   It should have an **optional** flag `--verbose` (`-v`) that, if present, prints extra information.

```python
import argparse

# --- Answer ---
parser = argparse.ArgumentParser(description="Calculate the area of a rectangle.")
parser.add_argument("length", type=float, help="The length of the rectangle.")
parser.add_argument("width", type=float, help="The width of the rectangle.")
parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output.")

# To test:
# args = parser.parse_args()
# area = args.length * args.width
# if args.verbose:
#     print(f"Calculating area for a {args.length}x{args.width} rectangle.")
# print(f"The area is: {area}")
```

## üìù Daily Assignment
**Goal**: Build a command-line tool for managing a simple to-do list.

The tool should support adding new items, listing all items, and marking items as complete. The to-do list items can be stored in a simple text file (`todos.txt`).

**Requirements:**
1.  **Main Command**: Your script will be called `todo.py`.
2.  **Subcommands**: Your CLI must be structured with the following subcommands:
    -   `add`: Adds a new to-do item.
        -   It must take one positional argument: the `description` of the to-do item (a string).
        -   Example: `python todo.py add "Buy milk"`
    -   `list`: Lists all to-do items.
        -   It should read `todos.txt`, and print each item with its line number (e.g., `1. Buy milk`).
        -   It should have an optional flag `--all` which also shows completed items.
        -   Example: `python todo.py list`
    -   `done`: Marks a to-do item as complete.
        -   It must take one positional argument: the `item_number` to mark as done.
        -   This should modify the item in the file, perhaps by prepending `[x]` to the line.
        -   Example: `python todo.py done 2`
3.  **Help Messages**: All commands, subcommands, and arguments must have clear and helpful `help` text.
4.  **File Handling**: The script should read from and write to a file named `todos.txt`.

**Example `todos.txt` content:**
```
Buy milk
[x] Call the dentist
Read a chapter of a book
```

## üìñ Further Reading
- [`argparse` ‚Äî Parser for command-line options, arguments and sub-commands](https://docs.python.org/3/library/argparse.html) (The official docs are very comprehensive)
- [`argparse` Tutorial](https://docs.python.org/3/howto/argparse.html)
- [Google's CLI design best practices](https://clig.dev/)
