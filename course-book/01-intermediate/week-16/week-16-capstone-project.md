# Week 16 Capstone Project: Performance-Critical Application

## üéØ Project Goal

To take a computationally expensive task‚Äîgenerating a Mandelbrot set fractal‚Äîand progressively optimize it using the techniques learned this week. The goal is to achieve at least a **10x performance improvement** over the initial, naive implementation, and to document the process and results.

## üìö Background

Fractal generation is a classic example of a CPU-bound, "embarrassingly parallel" problem. The calculation for each pixel is independent of the others, but requires a significant number of mathematical operations. This makes it a perfect candidate for performance analysis and optimization.

The Mandelbrot set is generated by iterating the function `z_{n+1} = z_n^2 + c` for each point `c` in the complex plane. If the value of `|z|` does not escape to infinity after a certain number of iterations, the point `c` is considered to be in the set. The number of iterations it takes to "escape" determines the color of the pixel.

This project will require you to use `NumPy` for a vectorized implementation, and `Cython` for a compiled implementation. You will also need `Pillow` to save the final image.

```bash
# Make sure you are in your project directory
poetry add numpy cython pillow
# For profiling
poetry add line_profiler memory_profiler snakeviz
```

## üìã Project Phases

### Phase 1: The Naive Pure Python Implementation

1.  **Create `mandelbrot_pure.py`**.
2.  Write a function `generate_mandelbrot_py(width, height, max_iter)` that:
    - Creates a 2D list or NumPy array to store the output image data.
    - Uses **two nested Python `for` loops** to iterate over each pixel `(px, py)` in the output image.
    - For each pixel, it maps the pixel coordinates to a complex number `c`.
    - It then iterates up to `max_iter` times, applying the `z = z*z + c` formula.
    - If `|z| > 2` at any point, the loop breaks, and the number of iterations is stored for that pixel.
    - If the loop completes, `max_iter` is stored.
3.  This implementation will be your baseline. It will be **very slow**.

### Phase 2: Profiling and Analysis

1.  **Benchmark the Baseline**: Write a `main.py` that calls your pure Python function and times its execution for a reasonably sized image (e.g., 500x500 with 100 iterations).
2.  **Profile with `cProfile`**: Run `python -m cProfile -o pure.prof main.py`. Analyze the output with `snakeviz` or `pstats`.
3.  **Profile with `line_profiler`**: Add the `@profile` decorator to your `generate_mandelbrot_py` function and run `kernprof -l -v main.py`.
4.  **Create `ANALYSIS.md`**: In this file, document your findings.
    - What did `cProfile` tell you about the function's overall time contribution?
    - What did `line_profiler` tell you about the "hot lines" inside the function?
    - This analysis justifies the need for optimization.

### Phase 3: NumPy Vectorization

1.  **Create `mandelbrot_numpy.py`**.
2.  Write a function `generate_mandelbrot_np(width, height, max_iter)`.
3.  This time, **avoid Python loops entirely**. The core idea is:
    - Create a grid of complex numbers `c` using `np.linspace` and `np.newaxis`.
    - Create a grid `z` initialized to zeros.
    - Create an output grid `output` initialized to zeros.
    - Loop `max_iter` times. In each loop, update the _entire_ `z` array at once (`z = z*z + c`).
    - You will also need a boolean mask to keep track of which points have "escaped" so you don't continue to update them.
4.  **Benchmark**: Update your `main.py` to time this new function. The performance improvement should be significant. Add the results to `ANALYSIS.md`.

### Phase 4: Cython Acceleration

1.  **Create `mandelbrot_cython.pyx` and `setup.py`**.
2.  Copy your **pure Python loop-based logic** (from Phase 1) into the `.pyx` file.
3.  **Add Static Types**: This is the most critical step.
    - Use `cdef` to declare all variables in your hot loops (`i`, `j`, `z`, `c`, loop counters) with C types (`int`, `double`, `double complex`).
    - The function signature should also be typed: `def generate_mandelbrot_cy(int width, int height, int max_iter):`.
4.  **Compile the Module**: Run `python setup.py build_ext --inplace`.
5.  **Benchmark**: Update `main.py` to import and time the Cython function. Add the results to `ANALYSIS.md`. This version should be the fastest.

## deliverables

Your final submission for this project should include:

1.  The three implementation files: `mandelbrot_pure.py`, `mandelbrot_numpy.py`, `mandelbrot_cython.pyx`.
2.  The `setup.py` file for compiling the Cython module.
3.  The `main.py` script used for benchmarking.
4.  The final `ANALYSIS.md` file containing:
    - A table comparing the execution times of the three versions.
    - Your analysis of the profiling results.
    - A conclusion explaining the results and the pros and cons of each optimization approach.
5.  An output image file (`mandelbrot.png`) generated by your fastest implementation, created using `Pillow`.

## üèÜ Bonus Challenges

1.  **Memory Profiling**: Use `memory_profiler` to compare the memory consumption of the NumPy and Cython versions. Which one is more memory-efficient and why? Add this to your analysis.
2.  **Parallelization**: The Mandelbrot calculation is "embarrassingly parallel." Use `concurrent.futures.ProcessPoolExecutor` to split the work of rendering the image across multiple CPU cores. Can you get another 2-4x speedup?
3.  **Advanced Colors**: Implement a more interesting color mapping algorithm instead of just using the raw iteration count.
4.  **Interactive Viewer**: Use the `Textual` knowledge from this week to create a simple TUI that lets you "pan" and "zoom" into the Mandelbrot set, recalculating and displaying the fractal each time.
